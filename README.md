# test-realtime-data

[TEST] realtime data display, Node.JS / Express / MongoDB + VanillaJS frontend

Решение тестового задания:
Из внешнего источника данных система получает обновления сущностей.

Реализованы 4 сервиса, для удобства в одном репозитории, в разных папках:

### Заглушка имитирующая внешний источник данных по отношению к нашей системе

[data-stub](data-stub/index.js) - сервер использует Redis в качестве системы для месседжей, случайный данные генерируются библиотекой facker со случайными задержками.
Написан простенький юнит-тест.
Запустить только этот сервис: `npm run run:stub`
По-умолчанию, настроено на использование sandbox Redis сервиса из Интернета, так что для тестов локальный Redis можно не иметь, либо указать через переменную:

```sh
REDIS_URL=redis://localhost:6379 npm run run:stub
```

### Cервис, который слушает обновление данных и хранит их

[data-subscriber](data-subscriber/index.js) - сервер подписывается на события на Redis сервисе и сохрнаяет получаемые месседжы в MongoDB со строгой JSON-schema валидацией (MongoDB >= 3.6).

По-умолчанию настроен на использование того же самого сервера Redis, и sandbox MongoDB, так что для теста ни то ни другое на локальной машине не нужно.
Запустить этот сервис вместе с генератором:

```sh
npm run run:pub-sub
```

Клиент Redis по-умолчанию сам бесконечное количество раз пытается восстановить связь с сервером и передподписаться, так что система устойчива к "изчезновению" внешнего источника данных.

### Сервис, который может отдать одну сущность или список всех сущностей в актуальном состоянии

[data-server](data-server/index.js) - сервер на Express.JS. Подключается (достаточно read-only прав) к MongoDB, и раздает клиентам одну конкретную сущность или актуальное состояние всех сущностей и затем передает через Server-Side Events (SSE) обновления всем подключенным клиентам.
Сервер непосредственно запрашивает данные c MongoDB сервера лишь один раз при запуске - для получения начального состояния, а затем подписывается на change stream MongoDB (>= 3.6) и получает обновления через него.

Через эндпоинт `/status` можно получить количество клиентов, подписанных в данный момент на обновления через SSE с этого сервера.

Запустить этот сервис:

```sh
npm run run:api

curl --silent http://localhost:3000/status | jq
# {
#   "clients": 0
# }
```

Запустить вместе с генератором данных:

```sh
npm run run:servers
```

### Клиентское приложение

[frontend](frontend/index.html) - написана в виде статического HTML, JS и CSS. Задачи совместимости с разными браузерами не было, поэтому из-за используемых технологий работает в последних Chrome и Firefox (для Safari нужен полифил чтобы сработало SSE c CORS).

Клиентское приложение подсоединяется к `data-server` через SSE и отображает начальное состояние и обновления даннных в реальном времени. Благодаря механизму SSE браузер сам восстанавливает соединение в случае временной недоступности сервера.

Механизм выбора цвета фона в зависимости от значения параметра, а также контрастного цвета текста [реализован полностью средствами CSS](frontend/style.css#L41) (через CSS переменные).

Перерасчет агрегируемых параметров происходит на клиенте в реальном времени.

Запустить только клиентскую часть:

```sh
npm run run:frontend
```

Запустить всю систему целиком:

```sh
npm run run:all
```

Возможно подключение множества клиентов одновременно (анимация в жизни приятней чем в GIF):
![клиенты](clients.gif)

### Комментарии

1. Вся архитектура системы в целом - push. Изменения по всей системе отправляются и отрисовываются только при публикации новых данных. Никаких poll/pull/таймеров и тп.

2. Все в реальном времени, но при необходимости можно легко добавить буферирование событий в data-server, что не создаст никакого backpressure на остальные компоненты системы.

3. Вся система практически бесконечно масштабируема горизонтально - можно запустить любое количество инстанций любой подчасти системы и она будет продолжать работать совместно (естественно перед data-server надо будет load balancer).
